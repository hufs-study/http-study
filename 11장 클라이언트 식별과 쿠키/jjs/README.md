# 11장 클라이언트 식별과 쿠키

서버가 통신하는 대상을 식별하는 데 사용하는 기술들

## 11.1 개별 접촉

웹 서버는 요청을 보낸 사용자들을 식별하거나, 연속적인 요청을 추적하기 위해 정보를 이용할 수 있다.

사용자들에 대해 많이 알고, 브라우징한 정보를 기록하고 싶어한다.

현대의 웹 사이트들은 다양한 방식으로 개인화된 서비스를 제공하려고 한다.

- 개별 인사 : 개인에게 맞춰진 메시지, 페이지 내용
- 사용자 맞춤 추천
- 저장된 사용자 정보 : 신용카드 정보 등
- 세션 추적 : stateless한 HTTP 트랜젝션에서 사용자와 상호작용을 위해 상태를 남김 (장바구니)

⇒ HTTP가 사용자를 식별하는데 사용하는 기술들

## 11.2 HTTP 헤더

- From : 사용자의 이메일 주소 (스펨 메일 문제로 발송하는 브라우저 적음)
- User-Agent : 사용자의 브라우저 정보
  - 특정 브라우저 속성에 따른 콘텐츠 최적화에 유용, 사용자 식별에는 도움 X
- Referer : 사용자가 현재 링크로 유입하게 한 웹페이지의 URL
  - 이전에 어떤 페이지를 방품했는지 알려줘 사용자 취향 파악에 도움

⇒ 부족한 정보

## 11.3 클라이언트 IP 주소

웹 서버는 HTTP 헤더가 아닌 요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아내어 크라이언트 IP 주소를 받을 수 있다.

약점이 존재.

- 사용자가 아닌 컴퓨터를 가리킴 : 다수 사용자일 때는 식별 불가
- ISP의 경우 동적 IP 주소 할당
- NAT 방화벽으로 실제 IP 주소를 숨김
- 프락시 서버의 IP 주소 (확장 헤더로 IP 주소를 추가하려는 방법도 고려함)

⇒ 현재는 제대로 동작하기 어려운 방식

## 11.4 사용자 로그인

- Authorization 헤더 : 웹 사이트에 사용자 이름과 비밀번호를 요청해서 명시적인 식별 가능.
  - 사이트는 401 Login Required HTTP 응답 코드 + WWW-Authenticate 헤더 반환 로그인 하라고 요청
  - 사용자가 이름, 비밀번호 입력 : 사용자 식별 시작
  - 이후에 브라우저는 서버로부터 사용자 식별 정보를 요청 받으면 식별정보 토큰을 Authorization 헤더에 담아 세션으로 유지

## 11.5 뚱뚱한 URL (사용자의 상태 정보를 포함한 URL)

사용자의 URL 마다 버전 기술하여 사용자 식별하고 추적

- URL에 상태 정보를 유지하는 하이퍼링크를 동적으로 생성
  - 웹 서버와 통신하는 독립적인 HTTP 트랜잭션을 하나의 ‘세션', ‘방문' 분기 처리 가능
    - 첫 접속시 유일 ID 생성 후 URL 추가되면, 서버가 그 URL로 리다이렉트 시켜준다.

⇒ 사이트를 브라우징하는 사용자들을 식별하는 데 사용할 수 있다.

⇒ 심각한 문제 존재

- 사용자들에게 혼란을 주는 URL
- 개인정보가 포함되어 외부에 공유가 불가능한 URL
- URL이 달라져 캐시를 사용할 수 없음
- URL에 따라 HTML이 달라져 서버 부하 커짐
- 사전에 세션 정보에 추가된 링크만 사용해야 URL 정상동작 (장바구니 날아가는 문제)
- URL 기억하지 않는 이상 세션 간 지속성 낮음

## 11.6 쿠키

### 11.6.1 쿠키의 타입

- Session Cookie
  - 사용자가 사이트 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키
  - 브라우저를 닫으면 삭제
  - Discard 파라미터 설정
  - Expires or Max-Age 파라미터가 없음
- Persistent Cookie
  - 디스크에 저장되어 길게 유지
  - 자주 방문하는 사이트에 대한 설정 정보, 로그인 이름 유지

### 11.6.2 쿠키는 어떻게 동작하는가

쿠키 = 서버가 사용자에게 붙이는 식별 스티커

- 사용자의 웹 사이트 첫 방문 이후 다시 돌아오면, 웹 서버는 식별을 위해서 유일 값을 쿠키에 할당한다
  - 임의의 이름 = 값 형태의 리스트를 가지고, 이 리스트는 Set-Cookie와 같은 HTTP 응답 헤더에 기술되어 사용자에게 전달된다.
  - 쿠키에는 다양한 정보가 담겨 저장될 수 있다.
  - 브라우저는 서버로 온 Set-Cookie 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 데이터 베이스에 저장하고, 이후 사용자 방문 시 이를 Cookie 요청 헤더에 기술해 전송한다.

### 11.6.3 쿠키 상자 : 클라이언트 측 상태

브라우저가 쿠키 정보를 저장할 책임 = 클라이언트 측 상태 = HTTP 상태 관리 체계

각 브라우저는 각기 다른 방식으로 쿠키를 저장한다

### 11.6.4 사이트마다 각기 다른 쿠키들

브라우저는 각 사이트에 두 개 혹은 세 개의 쿠키만을 보낸다.

- 쿠키 모두 전달하면 성능이 크게 저하된다.
- 서버에 특화된 이름/값 쌍의 쿠키들은 사이트에서 인식하지 않는 무의미한 값이 많다
- 모든 사이트에 쿠키 전달하는 것은 개인정보 문제를 야기한다.

⇒ 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.

- 광고 : 지속 쿠키의 도메인이 같다는 점, Referer 헤더를 활용해 여러 웹 사이트에서 쿠키를 사용해 사용자 데이터를 구축하기도 한다.

**쿠키 Domain 속성**

Set-Cookie 응답 헤더에 Domain 속성을 기술하여 어떤 사이트가 그 쿠키를 읽었는지 제어할 수 있다.

> **Set-cookie : user=”joo”; domain=”naver.com”**

naver.com 도메인을 가진 모든 사이트에 user 쿠키를 전달.

**쿠키 Path 속성**

웹 사이트 일부에만 쿠키를 적용

> **Set-cookie : pref=compact ; domain=”naver.com”; path=”/news/”**

news가 붙은 url 접근 시 user, pref 쿠키를 모두 받는다

⇒ 쿠키는 일종의 상태 정보, 서버가 생성하여 클라이언트에 전달하고, 클라이언트는 쿠키를 유효한 사이트에만 다시 전달하고 관리

### 11.6.6 Version 0(넷스케이프) 쿠키

Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는 데 필요한 필드들을 정의.

- Set-Cookie 헤더
  - 이름 = 값 (필수)
  - Expires, Domain, Path, Secure (선택)
- Cookie 헤더
  - 클라이언트가 서버에 요청 보낼 때, Domain, Path, Secure 필터들이 현재 요청하려는 사이트에 적합하며 파기되지 않은 쿠키를 함께 보낸다. 모든 쿠키는 Cookie 헤더에 한데 이어 붙여 보낸다.

### 11.6.7 Version 1 (RFC 2965) 쿠키

Set-Cookie2, Cookie2 헤더 + Version 0 과도 호환 가능 ⇒ 현재는 폐기되어 지원 되지 않는다.

### 11.6.8 쿠키와 세션 추적

서버는 응답에 두 개의 세션 쿠키를 기술하고 사용자를 다른 URl로 리다이렉트 시켜, 클라이언트는 이 쿠키를 포함하여 요청을 보낸다. 추가적인 트랜젝션 (페이지 이동)이 있으면 쿠키를 더하여 요청과 응답을 처리할 수 있다.

⇒ 연속적인 트랜젝션에서 사용자 식별을 위해 세션 쿠키를 사용

### 11.6.9 쿠키와 캐싱

쿠키 트랜잭션과 관련된 문서를 캐싱하는 쿠키 정보가 다른 사람에게 할당될 수 있고, 개인정보 노출이 있을 수 있으므로 위험.

- 캐시되지 말아야 할 문서가 있다면 표시
- Set-Cookie 헤더를 캐시하는 것에 유의
  - 여러 사용자에게 헤더를 보내게 되면 사용자 추적에 실패
  - 응답 저장 전 헤더가 제거된 데이터에서 문제가 발생
    - 모든 요청마다 원 서버와 재검사를 통해 Set-Cookie 값을 추가하여 개선 가능
- Cookie 헤더를 가지고 있는 요청 주의
  - 요청이 Cookie와 함께 오면, 결과 콘텐츠가 개인정보를 담고 있을 수도 있다.

### 11.6.10 쿠키, 보안 그리고 개인정보

DB에 개인 정보를 젖아하고 데이터의 key값을 쿠키에 저장한다면, 예민한 데이터가 오가는 것을 줄일 수 있다.

제공하는 개인정보를 누가 받는지 정확히 알고, 개인정보 정책에 유의한다면 사용에 있어 편리함을 높일 수 있다.
