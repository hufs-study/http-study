# 6장 프락시

## 6.1 웹 중개자

HTTP 프락시 서버는 웹 서버와 클라이언트처럼 동작한다.

### 6.1.1 개인 프락시와 공유 프락시

- **공용프락시**

  여러 클라이언트가 함께 사용하는 프락시

  - 대부분의 프락시로 캐시 프락시와 같이 사용자가 많을수록 여러 사용자들의 공통된 요청에서 이득을 취할 수 있기에 비용효율이 높고 쉽다.

- **개인프락시**
  하나의 클라이언트만을 위한 프락시
  - 클라이언트 컴퓨터에 직접 실행된다. (ISP 서비스를 위한 광고나 브라우저 확장 기능, 성능 개선)

<br>

### 6.1.2 프락시 대 게이트웨이

프락시는 같은 프로토콜을 연결, 게이트웨이는 다른 프로토콜을 연결 (프로토콜 변환기처럼 동작)

- 프락시 (HTTP ↔  HTTP)
- 게이트웨이 (HTTP ↔  POP) : 웹 → POP 트랜잭션으로 변환해서 이메일을 HTTP를 통해 읽을 수 있게한다.

⇒ 사실상 차이는 모호 : 브라우저, 서버가 다른 버전의 HTTP 구현해서 프락시도 프로토콜 변환도 하며 SSL, 방화벽, 웹 기반 어플리케이션 지원 등 게이트웨이 기능도 한다.

<br>

## 6.2 왜 프락시를 사용하는가?

프락시 서버는 모든 HTTP 트래픽을 감시하며 실용적인 서비스 구현을 위해 동작한다.

- 악성 콘텐츠 등 필터링 소프트웨어
- 문서 접근 제어
- 보안 방화벽
  - 어플리케이션 레벨 프로토콜 흐름을 네트워크에서 통제 : 트래픽 관련 웹훅도 구현 가능
- 웹 캐시
  - 문서의 로컬 사본 제공으로 성능 향상
- 대리 프락시 : 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션
  - 서버 가속기, 리버스 프락시 : 공용 컨텐츠에 대한 느린 웹 서버 성능 개선, 콘텐츠 라우팅 기능으로 분산 네트워크 형성
- 콘텐츠 라우터
  - 콘텐츠의 종류에 따라 특정 웹 서버로 유도 (캐시 등을 위해 요금별 서비스를 제공하는 서비스)
- 트랜스코더 : 중개자에 의한 콘텐츠 변형
  - 이미지, 텍스트 크기 줄이기 위해 형식 변환 : 국제화, 반응형 서비스도 이용가능
- 익명화 프락시 : HTTP 메시지에서 신원 식별 특성 제거로 보안성 높아짐
  - User-Agent 헤더에서 컴퓨터와 OS 종류 제거
  - 이메일 주소 보호 From 헤더 제거
  - Cookie 헤더 제거
  ⇒ 브라우저 경험의 질이 떨어지지 않기 위해 주의 필요

<br>

## 6.3 프락시는 어디에 있는가?

### 6.3.1 프락시 서버 배치

- 출구(Egress) 프락시
  - 더 큰 서버로 가는 트래픽을 제어하기 위해 네트워크 출구에 위치한 프락시
    - 해커 막는 방화벽, 인터넷 요금 절약, 트래픽 성능 개선, 필터링 출구 프락시
- 접근(입구) 프락시
  - 모든 요청을 종합적으로 처리하기 위해 접근 지점에 ISP 위치
    - 다운로드 속도 개선, 인터넷 대역폭 비용 줄이기 위한 캐시 프락시
- 대리 프락시(리버스 프락시)
  - 웹 서버로 향하는 모든 요청 처리하고, 필요할 때 웹 서버에게 자원을 요청
    - 보안기능 추가, 캐시 서버 추가
- 네트워크 교환 프락시
  - 라우터 사이에 배치 (대역폭 관리, 트래픽 흐름 감시)

<br>

### 6.3.2 프락시 계층

클라이언트 ↔  아웃바운드 프락시1 ↔  프락시2 ↔  인바운드 프락시3 ↔  서버

- 프락시 계층 콘텐츠 라우팅
  단순한 정적인 메세지 전달만이 아닌 다양한 이유에 의해서 유동적으로 다른 서버에 전달가능.
  **동적 부모 선택**
  - 부하 균형
    - 부하 분산을 위해서 현재 부모들의 작업량 수준에 근거하여 부모 프락시를 고른다.
  - 지리적 인접성에 근거한 라우팅
    - 원 서버의 지역을 담당하는 부모를 선택
  - 프로토콜/타입 라우팅
    - URI 근거하여 다른 부모나 원 서버로 라우팅. (특정 URI → 특정 프락시 서버)
  - 유료서비스 가입자를 위한 라우팅
    - 추가금 지불에 대한 서비스 (대형 캐시, 성능 개선을 위한 압축 엔진)

<br>

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가

- **클라이언트 수정**
  - 웹 요청에서 흔히 쓰이는 수동 혹은 자동 프락시 설정
- **네트워크 수정**
  - 인터셉트 프락시 : 스위칭 장치와 라우팅 장치를 이용해 HTTP 트래픽을 지켜보고 (네트워크 인프라) 가로채 프락시로 보낸다
- **DNS 이름공간 수정**
  - 대리 프락시로 웹서버의 이름과 IP 주소를 사용한다. DNS 이름 테이블을 편집하거나 적절한 프락시나 서버를 계산해주는 동적 DNS 서버로 이용
- **웹 서버 수정**
  - HTTP 리다이렉션 명령을 돌려주어 프락시와 트랜젝션하게 만든다

<br>

## 6.4 클라이언트 프락시 설정

브라우저가 프락시 설정을 위해 제공하는 방법

### 6.4.1 클라이언트 프락시 설정 : 수동

프락시의 호스트와 포트를 지정하며, 리다이랙트 되어지기도 한다.

<br>

### 6.4.2 클라이언트 프락시 설정 : PAC파일

수동 프락시의 단순한 설정에 의한 확장성의 단점에 대한 자바스크립트를 활용한 동적인 해결책

- JS PAC 파일(.pac / MIME 타입 ‘application/x-ns-proxy-autoconfig’)의 URI를 브라우저에 설정해주어 매 접근마다 적절한 자바스크립트 로직을 이용한다.

[Proxy Auto-Configuration (PAC) file - HTTP | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling/Proxy_Auto-Configuration_PAC_file)

<br>

### 6.4.3 클라이언트 프락시 설정 : WPAD

웹 프락시 자동발견 프로토콜 (Web Proxy Autodiscovery Protocol)

- PAC 파일을 자동으로 찾아주는 알고리즘
  구현된 클라이언트가 하게 될 일
  - PAC URI를 찾기 위해 WPAD 사용
  - UR에서 PAC 파일을 가져온다
  - 프락시 서버를 알아내기 위해 PAC 실행
- 여러 리소스 발견 기법을 쓰고 있다.

<br>

## 6.5 프락시 요청의 미묘한 특징들

### 6.5.1 프락시 URI는 서버 URI와 다르다

클라이언트가 프락시 대신 서버로 요청을 보내면 요청의 URI가 달라진다.

- 클라이언트 → 프락시 : URI 완전한 형태로 가짐(스킴, 호스트, 포트번호 포함)

**이유는 ?**

초기 HTTP 설계에서 클라이언트는 단일 서버에게 호스트 명과 포트번호를 보낼 필요가 없었고 프락시가 등장하면서 서버와 커넥션을 맺기 위해서 차이가 발생

→ 기존 구축 웹 서버 요청에서는 부분 URI로 구현되는 경우가 있음

→ HTTP/1.1의 경우 프락시와 서버 요청 모두에 대해 서버들이 완전한 URI를 다룰 것을 요구한다. 명시적으로 설정된 클라이언트 프락시 설정의 경우에는 요청을 어떻게 보내야하는지 알 수 있다.

<br>

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

프락시에서 ‘스킴/호스트/포트번호 누락' 문제는 가상 호스팅에서 접근하고자하는 웹 사이트의 호스트명을 알필요가 있는 것과 같은 문제. (호스트와 포트에 대한 정보가 담긴 Host 헤더로 해결)

- 명시적인 프락시의 완전한 URI 요청으로 해결

<br>

### 6.5.3 인터셉트 프락시는 부분 URI를 받는다

클라이언트가 보지 못하는 프락시 (인터셉트 프락시, 리버스 프락시)에 의해 부분 URI를 보낼 수 있음

<br>

### 6.5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다

- 완전한 URI 주어졌다면, 프락시는 그것을 사용해야한다.
- 부분 URI 주어지고 Host 헤더가 있다면, Host 헤더를 이용해 원 서버의 이름과 포트 번호를 알아내야한다.
- 부분 URI가 주어졌으나 Host 헤더가 없다면
  - 대리 프락시의 경우, 프락시에 실제서버 주소와 포트번호가 있을 수도 있다.
  - 이전에 인터셉트 프락시가 가로챘던 트래픽에서 IP 주소와 포트번호 사용이 가능할 수 있다.
  - 실패한다면 에러메시지를 반환해야한다

<br>

### 6.5.5 전송 중 URI 변경

표준 형식으로 ‘정규화'하는 과정에서 상호운용성 문제가 일어날 수 있기 때문에 프락시 서버는 관대하도록 해야한다. HTTP 명세는 인터셉트 프락시가 URI 전달 시에 절대 경로를 고쳐 쓰는 것을 금지한다. (빈 경로 제외)

<br>

### 6.5.6 URI 클라이언트 자동확장과 Hostname Resolution

브라우저는 프락시 존재 여부에 따라 요청 URI 다르게 분석한다

- 프락시 없으면 사용자가 타이핑한 URI
- 발견되면 대응하는 IP 주소를 계속해서 시도
  ⇒ 호스트가 발견되지 않는다면 호스트 명의 ‘확장'을 제공

<br>

### 6.5.7 프락시 없는 URI Resolution

<br>

### 6.5.8 명시적인 프락시를 사용할 때의 URI 분석

브라우저가 URI 프락시를 지나치기 때문에 부분 호스트명을 자동확장하지 않기에 프락시는 부분 호스트 명을 얻는다.

<br>

### 6.5.9 인터셉트 프락시를 이용한 URI 분석

- 성공적으로 호스트 명을 분석하고 IP 주소 목록을 받은 클라이언트는 접속을 시도한다.
- 일부 서버는 죽은 것일 수도 있지만 인터셉트 프락시가 트래픽을 가로채서 이 사실을 모른채 접속이 종료된다.
- 프락시가 원 서버와 상호작용할 준비가 되었을 때, 다운된 서버를 알게 된다.
- 브라우저에서 제공하는 것과 동등한 수준의 ‘장애 허용'을 제공하기 위해서, 프락시는 호스트명을 다시 분석하거나 역방향 DNS 룩업을 해서 다른 IP 주소를 시도해야한다. (명시적인 프락시 설정에서도 장애 허용은 프락시에 달려 있어 죽은 서버의 DNS 분석에 대한 장애 허용은 중요)

<br>

## 6.6 메시지 추적

캐시 프락시 서버 등 다양하게 이용되는 프락시를 이동하는 메시지의 흐름을 추적하고 문제를 찾는 것도 필요해졌다.

<br>

### 6.6.1 Via 헤더

HTTP 메시지의 Via 헤더 필드는 메시지가 지나는 각 중간 노드(프락시, 게이트웨이)의 정보를 나열한다. (반드시 추가되어야한다)

- 메시지의 전달을 추적하고, 메시지 루프를 진단하고 요청을 보내고 응답을 돌려주는 과정에 관여하는 모든 메시지 발송자들의 프로토콜을 다루는 능력을 알아보기 위해 사용됨.
- 네트워크 라우팅 루프를 탐지하기 위해 사용
  - 요청을 보내기전 자신을 가리키는 유니크한 문자열을 삽입하고 요청에 있는지 검사해야함.

**Via 문법**

> Via : 1.1 proxy-62.irenes-isp.net , 1.0 cache.joes-hardware.com

⇒ 프로토콜 이름 / 프로토콜 버전 / 노드 이름 / 노드 코멘트

- **프로토콜 이름**
  - HTTP라면 생략이 가능하고, 비 HTTP 프로토콜은 게이트웨이가 다른 프로토콜을 위해 HTTP 요청에 접속할 때 발생할 수 있다.
- **프로토콜 버전**
- **노드 이름**
  - 중개자의 호스트와 포트 번호. 가명을 대체 가능
- **노드 코멘트**
  - 벤더나 버전 정보를 포함시키고, 장치에서 일어난 이벤트에 대한 진단정보 (캐시 프락시의 적중/ 부적중 정보) 선택적인 코멘트

**Via 요청과 응답 경로**

요청 메시지도 응답의 반대로 (보통 같은 TCP 커넥션)

**Via와 게이트웨이**

Via 헤더의 프로토콜 변환 기록을 이용해 그 사실을 알 수 있다.

**Server 헤더와 Via 헤더**

Server 응답 헤더 필드는 원 서버에 의해 사용되는 소프트웨어를 알려준다

> Server : Apache/1.3.14 (Unix) PHP/4.0.4

응답 메시지가 프락시를 통과할 때, 프락시는 원 서버를 위해 존재하는 Server 헤더를 수정해서는 안되고 Via 항목을 추가해야한다.

**Via가 개인정보 보호와 보안에 미치는 영향**

네트워크 아키텍처에 의한 정보를 보호하기 위해서 노드 이름을 가명을 정해주거나 프로토콜이 같을 경우 Via 경로 항목들을 하나로 합칠 수 있다.

<br>

### 6.6.2 TRACE 메서드

프락시 서버는 메시지가 전달될 때 메시지를 바꾸며 형식이 변환되어 상호운용성 문제가 증가. 홉에서 홉으로 전달 될 때 메시지의 내용을 관찰하는 방법이 필요.

- **Max-Forwards**
  TRACE, OPTIONS의 프락시 홉 개수를 제한하기 위해 사용.
  - 메시지 무한 루프, 프락시 연쇄 테스트, 중간 서버 효과 체크

<br>

## 6.7 프락시 인증

접근 제어 장치 역할. HTTP에서 유효한 접근 권한에 대한 요청 허용 및 차단에 이용.

- 제한된 컨텐츠에 대해 407 Proxy Authorization Required(자격 요구) + Proxy-Authenticate(자격 제출 가능 설명)
- 클라이언트는 자격 수집해야하고, 헤더 필드에 담아서 요청

<br>

## 6.8 프락시 상호 운용성

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

이해할 수 없는 헤더필드는 그대로 전달하고, 같은 이름의 헤더 필드가 여러 개 있는 경우 상대적인 순서 유지 필요.

<br>

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기

서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 해주는 OPTIONS를 이용해 서로 다른 기능 수준의 서버와 프락시가 더 쉽게 상호작용할 수 있도록 해준다.

- 지정한 리소스에 대한 기능 서술한 필드를 반환

<br>

### 6.8.3 Allow 헤더

요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드 열거.

> Allow : GET, HEAD, PUT

⇒ 지원했으면 하는 메서드를 추천하기 위해 요청 헤더로 사용되기도 함. 프락시는 모르는 메서드가 있어도 필드를 수정할 수 없다. (다른 경로가 있을 수도 있기 때문)
