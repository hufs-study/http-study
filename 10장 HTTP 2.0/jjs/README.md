# 10장 HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

HTTP/1.1은 구현의 단순성과 접근성에 집중 ⇒ 요청, 응답 교환방식에서 회전 지연 발생

SPDY : 구글이 개발한 HTTP 속도 개선 프로토콜

- 헤더를 압축하여 대역폭을 절약
- 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄임
- 능동적으로 리소스 푸시

이를 기반으로 HTTP/2.0 프로토콜 설계

## 10.2 개요

HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작. 커넥션 초기화는 클라이언트.

HTTP/2.0 요청과 응답은 헤더가 압축되어 한 개 이상의 프레임에 담긴다.

프레임에 담긴 요청과 응답은 스트림이 1:1로 처리하고, 커넥션 위에 여러 개의 스트림이 동시에 만들어 질 수 있으며 우선 순위와 흐름 제어 기능도 제공한다.

서버 푸시 도입 : 요청을 받지 않더라도 필요하다고 생각하는 리소스를 보내줄 수 있음

호환성을 유지하기 위해 요청과 응답 메시지 의미는 HTTP/1.1과 같도록 유지하고 있음.

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

<img src="./img/frame.png" />

### 10.3.2 스트림과 멀티플렉싱

스트림 : HTTP/2.0 커넥션을 통해 클라이언트 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스

클라이언트가 새 스트림 생성 후 HTTP 요청을 보내고 서버는 그 스트림에 응답을 실어 보내고 스트림이 닫힌다.

하나의 커넥션에 여러 개의 스트림이 동시에 열려서 여러 개의 요청이 동시에 보내질 수 있다.

스트림은 중요한 리소스에 대한 우선순위를 가질 수 있다.

서버, 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만들어 TCP 패킷을 주고 받는 시간 낭비를 안해도 된다.

커넥션에 한 번 사용한 스트림의 식별자는 고갈 되기도 하는데 다시 커넥션을 맺으면 된다.

여러 개의 스트림으로 블록되는 것을 흐름 제어를 통해 스트림이 망가지는 것을 막아준다.

### 10.3.3 헤더 압축

HPACK 명세에 따라 리소스의 크기가 커지면서 헤더는 압축되어 헤더 블록 조각들로 쪼개져서 전송된다. 받는 쪽에서는 압축 콘텍스트를 사용하여 압축을 해제 하고, 송신 측은 압축 콘텍스트가 변경 되었다고 가정하기에 수신 측은 반드시 압축 해제를 수행해야한다.

### 10.3.4 서버 푸시

서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용.

⇒ 클라이언트가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하는 트래픽과 회전 지연을 줄여줌.

스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안된다.

- 중간 프락시가 추가 리소스를 전달하지 않을 수 있고, 서버로부터 받지 않았어도 추가 리소스를 전달 할 수도 있다.
- 안전하고 캐시 가능하고 본문을 포함하지 않은 요청에 대해서만 푸시할 수 있다.
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다.
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책에 따라 검사해야한다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

HTTP/2.0 ⇒ HTTP/1.0 변환 시 발생

HTTP/2.0의 경우 헤더 필드의 이름과 값을 바이너리로 인코딩하여 어떤 문자열이든 사용할 수 있게 하여 정상적인 요청이나 응답이 위조된 HTTP/1.1 메시지로 번역되는 것 유발

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

커넥션이 오래 유지되어 개인 정보 유출에 악용될 수 있다.
