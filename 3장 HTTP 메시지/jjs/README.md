# 3장 HTTP 메시지

어떻게 메시지를 전달하는가 → **어떻게 메시지를 만들고 이해하는가**

<br>

## 3.1 메시지의 흐름

HTTP 메시지는 ‘HTTP 어플리케이션 간에 주고받은 데이터의 블록들’ 이다.

- 텍스트 메타 정보(메시지 내용과 의미)로 시작하고 다음에 선택적으로 데이터가 올 수 있다.
- 클라이언트, 서버, 프록시 사이를 흐르며 메시지의 방향을 나타내는 용어들이 있다.

<br>

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신한다

트랜젝션 방향을 표현하기 위해 사용

- 인바운드 : 서버 방향으로 이동
- 아웃바운드 : 처리가 끝난 뒤 사용자 에이전트로 돌아오는 것

<br>

### 3.1.2 다운스트림으로 흐르는 메시지

- 요청, 응답 메시지에 관계없이 모두 다운스트림으로 흐른다.
- 메시지의 발송자는 수신자의 업스트림이다.

<br>

## 3.2 메시지의 각 부분

각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함한다.

- 시작줄 : 어떤 메시지인지 서술
- 헤더 : 속성
- 본문 : 데이터
  - 헤더와 시작줄은 줄 단위로 분리된 아스키 문자열
  - 본문은 선택적 데이터 덩어리 (텍스트나 이진 데이터 혹은 비어있음)
  - 헤더는 본문에 대한 정보를 준다 (Content-Type, Content-Length…)

<br>

### 3.2.1 메시지 문법

모든 HTTP 메시지는 요청 / 응답 으로 분류된다.

- 요청 메시지

> <메서드> <요청 URL> <버전>
> <헤더>
> <엔터티 본문>

- 응답 메시지

> <버전> <상태 코드> <사유 구절>
> <헤더>
> <엔터티 본문>

- **메서드**
  클라이언트가 서버에게 수행해주길 바라는 동작 (GET, HEAD, POST …)
- **요청 URL**
  요청 대상이 되는 리소스를 지칭하는 URL의 경로 구성요소
- **버전**
  HTTP의 버전 ( HTTP/<메이저>.<마이너> )
- **상태 코드**
  요청 중에 무엇이 일어났는지 설명하는 세자리 숫자 (201, 400 …)
- **사유 구절(reason-phrase)**
  상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구 (NOT OK, OK …)
- **헤더**
  이름, 콜론(:), 선택적인 공백, 값, CRLF(빈 줄)가 순서대로 나타나는 0개 이상의 헤더들.
- **엔터티 본문**
  임의의 데이터 블록 (없다고 하더라고 항상 빈 줄(CRLF)로 끝나야 한다. ⇒ 규칙을 지키지 않는 부분과의 호환을 위해 없이도 받아들일 수 있어야 함)

<br>

### 3.2.2 시작줄

- **요청줄**
  - 서버에게 리소스에 대해 무언가를 해달라고 부탁한다.
- **응답줄**
  - 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
- **메서드**
  - 모든 서버가 많이 쓰이는 HTTP 메서드를 구현한 것은 아니며, 손쉽게 확장될 수 있는 HTTP의 특성에 따라 추가로 메서드를 구현했을 수 있다. 추가 메서드는 HTTP 명세를 확장하는 것이기 때문에 ‘확장 메서드'라고 불린다.
- **상태 코드**
  - 클라이언트에게 무슨 일이 일어났는지 말해주는 것
  - 숫자로 된 코드는 프로그램이 에러를 처리하기 쉽게 해준다.
- **사유 구절**
  - 상태코드에서 사람이 이해하기 쉬운 버전
- **버전 번호**
  - 어플리케이션이 지원하는 가장 높은 HTTP 버전
  - 2.22 > 2.2

<br>

### 3.2.3 헤더

헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다.

이름-값 쌍의 목록이다 ( Content-length: 19 )

- 헤더 분류
  - 일반 헤더 (요청, 응답), 요청 헤더, 응답 헤더
  - Entity 헤더 : 본문 크기와 콘텐츠, 리소스 그 자체
  - 확장 헤더 : 명세에 정의되지 않은 새로운 헤더

<br>

### 3.2.4 엔터티 본문

HTTP 메시지의 화물 (수송 내역) : 여러 종류의 디지털 데이터를 실어 나를 수 있다. ( 이미지, 비디오, HTML, 신용카드 트랜잭션, 전자우편… )

<br>

### 3.2.5 HTTP/0.9

너무나 단순한 구성으로 (요청은 메서드와 요청URL, 응답은 엔터티) 다양한 상황에 대응할 수 없어 HTTP 기능과 어플리케이션을 구현할 수 없다.

<br>

## 3.3 메서드

메서드는 제한적으로 이용된다. (모두 구현하지 않기 때문 : 일반적으로 서버 설정)

<br>

### 3.3.1 안전한 메서드

HTTP 요청의 결과로 인해 서버에서 일어나는 일이 없다. (GET, HEAD)

- 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 어플리케이션을 만들 수 있도록 하는 것에 있다.

<br>

### 3.3.2 GET

서버에게 리소스를달라고 요청하기 위해 사용된다.

- HTTP/1.1은 서버가 GET을 구현할 것을 요구

<br>

### 3.3.3 HEAD

GET과 같게 동작하지만, 서버는 응답으로 헤더만을 돌려준다. (엔터티 본문이 없다)

- 클라이언트가 리소스를 실제로 가져올 필요없이 헤더만을 조사할 수 있도록 해준다.
  - 리소스 없이 타입 등을 알아낼 수 있다.
  - 응답의 상태코드를 통해 개체가 존재하는지 확인할 수 있다.
  - 헤더를 확인하여 리소스 변경을 검사할 수 있다.
- HTTP/1.1은 서버가 HEAD를 구현할 것을 요구

<br>

### 3.3.4 PUT

서버에 문서를 쓴다. 리소스(파일)에 데이터를 입력하기 위해 사용.

- 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 있다면 본문을 사용해서 교체한다.
- 컨텐츠를 변경하는 작업이므로 많은 웹 서버가 사용자에게 비밀번호 입력으로 로그인을 요구한다.

<br>

### 3.3.5 POST

서버에 입력 데이터를 전송하기 위해 설계됨.

- HTML 폼을 지원하기 위해 흔히 사용됨
- 데이터를 서버에 전송하고, 서버는 그 데이터를 바탕으로 필요로 하는 곳에 보낸다.
- 메시지의 엔터티 본문에 데이터를 넣는다.

<br>

### 3.3.6 TRACE

클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.

- TRACE 요청은 목적지 서버에서 LoopBack 진단을 시작한다.
  - 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다.
  - 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 어플리케이션(방화벽, 프록시, 게이트웨이 등)의 요청/응답 연쇄를 따라가며 메시지의 상태(변경, 에러)를 확인할 수 있다.
  - 프락시나 다른 어플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 사용된다.
- 중간 어플리케이션이 여러 다른 종류의 요청(GET, POST)들을 일관되게 다룬다고 가정하는 문제가 있다.
  - 프락시는 POST 요청을 바로 서버로 통과시키지만, GET 요청은 웹 캐시와 같은 다른 HTTP 어플리케이션으로 전송한다. TRACE는 메서드를 구별하는 메커니즘이 없어 TRACE 요청 처리는 일반적으로 중간 어플리케이션이 결정을 내린다.
- TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없어 본문에는 서버가 받은 요청이 그대로 들어있다.

<br>

### 3.3.7 OPTIONS

서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어본다.

- 서버는 자신의 리소스에 대해 지원하는 메서드의 목록을 반환한다.
- 리소스에 대해서 실제로 접근하지 않고도 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트에 제공한다.

<br>

### 3.3.8 DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

- HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문에 삭제가 수행되는 것을 보장하지 못한다.

<br>

### 3.3.9 확장 메서드

Postel의 법칙 ‘be conservative in what you send, be liberal in what you accept’ (엄격하게 보내고 관대하게 받아들여라)

- 서버에서 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.
  - 확장 메서드는 다른 어플리케이션에서 이해할 수 없는 경우가 많으므로 위의 규칙과 같이 확장 메서드에 대해 관용적인 것이 좋다.

<br>

## 3.4 상태 코드

클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

<br>

### 3.4.1 <100-199> : 정보성 상태코드

HTTP/1.1에서 도입됨

**100 Continue** : 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야한다. 서버는 반드시 요청을 받아 응답해야 한다.

- HTTP 클라이언트 어플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 내용을 서버가 받아들일 것인지 확인하는 작업을 최적화하기 위한 의도로 도입 되었다.
- 클라이언트와 100 Continue
  - 클라이언트가 서버에 엔터티를 보내고, 그 전에 100 Continue 응답을 기다리는 상황
    ⇒ 클라이언트는 값을 100-continue로 하는 Expect 요청 헤더를 보낼 필요가 있다.
    ⇒ 엔터티를 보내지 않으려 한다면 Expect 헤더를 보내지 않아야 서버가 혼란스럽지 않음.
    (Expect 헤더는 서버가 어떻게 동작하기를 기대하고 있는지 알려주기 위해 클라이언트가 사용한다. Expect : 100-continue)
  - 최적화를 위한 응답 코드로, 클라이언트는 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 ‘보내지 않으려는' 목적으로만 사용해야 한다.
  - 클라이언트는 Expect 헤더를 보내고도 서버가 100 Continue 응답을 보내기를 기다리는 것이 아니라 그냥 엔터티를 보내야하며, 예상치 못한 응답에도 대비해야한다.
- 서버와 100 Continue
  - 서버는 절대로 Expect 하지 않은 클라이언트에게 100 Continue를 보내서는 안된다.
  - 응답을 보내기 전 엔터티의 일부나 전체를 수신하였다면 상태 코드를 보낼 필요가 없지만 요청을 끝까지 다 읽은 후에는 최종 응답을 보내야 한다.
  - 중간에 엔터티 본문을 읽기 전에 요청을 끝내기로 결정했으면, 응답을 보내고 연결을 끊으면 안된다. (클라이언트가 응답을 받을 수 없게 되기 때문)
- 프락시와 100 Continue
  - 프락시는 다음 홉 서버를 위해 Expect 헤더를 포함시켜서 요청을 전달해야한다.
    - 다음 홉 서버가 HTTP/1.1보다 이전 버전의 HTTP를 따른다면 417 Expectation Failed 에러를 응답해야한다.
    - HTTP/1.0이나 그 이전 버전의 클라이언트 대신 Expect 헤더와 100-continue 값을 요청 포함시키는 경우에는 클라이언트에 응답을 전달해서는 안된다.
      ⇒ 다음 홉 서버의 상태나 지원 HTTP 버전을 기억해둔다면 요청을 더 잘 다룰 수 있게 된다.

<br>

### 3.4.2 <200-299> : 성공 상태 코드

서버가 대응하는 성공을 의미하는 상태 코드들

<br>

### 3.4.3 <300-399> : 리다이렉션 상태 코드

클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 리소스의 내용 대신 다른 대안 응답을 제공한다.

리소스가 옮겨졌다면, 그 위치를 찾을 수 있게 하기 위해서 리다이렉션 상태 코드와 Location 헤더를 보내 알아서 새 위치로 이동할 수 있게 해준다.

상태 코드 중 리소스에 대한 어플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.

- 302, 303, 307 상태코드에서 중복이 있는 부분
  ⇒ 적절한 리다이렉트 상태 코드를 선택하기 위해 클라이언트의 HTTP 버전을 검사할 필요가 있다.
  ⇒ HTTP/1.0, HTTP/1.1 어플리케이션이 다루는 방식에서 차이가 있다.
  - HTTP/1.0 클라이언트가 POST 요청을 보내고 302 리다이렉트 응답을 받으면
    ⇒ 클라이언트는 Location 헤더에 들어있는 리다이렉트 URL을 GET요청으로 따라간다.
  - HTTP/1.0 서버가 HTTP/1.0 클라이언트로부터 POST 요청을 받은 뒤 302 응답을 받으면
    ⇒ 서버는 클라이언트가 리다이렉션 URL에 대한 GET 요청으로 따라가길 기대한다.
    ⇒ HTTP/1.1에서는 이 경우 303을 사용한다.
    ⇒ 혼란을 막기 위해 HTTP/1.1 명세는 HTTP/1.1 클라이언트의 일시적 리다이렉트를 위해 302 대신 307을 사용하라고 한다.
    ⇒ 서버는 302 상태 코드를 HTTP/1.0 클라이언트에게 사용하기 위해 남겨둘 수 있다.

<br>

### 3.4.4 <400-499> : 클라이언트 에러 상태 코드

클라이언트에서 서버가 다룰 수 없는 무엇인가를 보낸 경우.

- 가장 흔한 404 Not Found (존재하지 않는 URL)
- 대부분 브라우저에 의해 처리된다

<br>

### 3.4.5 <500-599> : 서버 에러 상태 코드

서버 자체의 에러 : 클라이언트가 제한이 걸린 것일 수도 있다.

프락시가 클라이언트의 입장에서 서버와 대화를 시도할 때 나타날 수 있다.

<br>

## 3.5 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.

<br>

### 3.5.1 일반 헤더 (General Header)

클라이언트와 서버 양쪽 모두가 사용하며, 메세지에 대한 기본적이고 유용한 정보를 제공한다.

<br>

### 3.5.2 요청 헤더 (Request Header)

서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지 등의 부가 정보나 요청 대상의 정보를 통해 더 나은 응답을 제공한다.

- Accept 관련 헤더
  - 클라이언트가 Accept 헤더를 통해 자신의 선호와 능력을 알려준다.
  - 클라이언트는 원하는 것을 얻을 수 있고, 서버는 클라이언트와 관련된 정보만 전송하여 시간과 대역폭 낭비를 줄일 수 있다.
- 조건부 요청 헤더
  - 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있다.
- 요청 보안 헤더
  - HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다.
    ⇒ 클라이언트가 어느 정도의 리소스에 접근하기 전에 자신을 인증하여 트랜잭션을 더 안전하게 만든다.
- 프락시 요청 헤더

<br>

### 3.5.3 응답 헤더 (Response Header)

클라이언트에게 부가 정보를 제공한다. (응답자, 응답자의 기능, 응답에 대한 설명)

- 협상 헤더
  - 여러 리소스들에 대해서 어떤 표현을 택할지에 대한 서버와 클라이언트의 협상
- 응답 보안 헤더
  - HTTP 인증요구/응답 체계에서 응답 측에 해당

<br>

### 3.5.4 엔터티 헤더 (Entity Header)

엔터티 본문에 부가적으로 더해지는 헤더 : 수신자에게 서버가 다루고 있는 것이 무엇인지 말해줌.

엔터티와 데이터들에 대한 개체 타입, 리소스 요청 메서드 등의 광범위한 정보를 제공한다

- 콘텐츠 헤더
  - 엔터티의 콘텐츠에 대한 구체적인 정보 제공 : 종류, 크기 등
- 엔터티 캐싱 헤더
  - 캐싱 시점과 유효성에 관한 정보 제공
