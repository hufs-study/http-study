# 8장 통합점 : 게이트웨이, 터널, 릴레이

## 8.1 게이트웨이

리소스와 애플리케이션을 연결하는 역할 (요청을 받고 처리)

### 8.1.1 클라이언트 측 게이트웨이와 서버 측 게이트웨이

웹 게이트웨이는 한쪽은 HTTP로 다른쪽(클라이언트, 서버)은 HTTP가 아닌 다른 프로토콜로 통신.

## 8.2 프로토콜 게이트웨이

### 8.2.1 HTTP/\*: 서버 측 웹 게이트웨이

클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환한다.

### 8.2.2 HTTP/HTTPS: 서버 측 보안 게이트웨이

사용자 세션(웹 요청) 암호화

### 8.2.3 HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이

인터셉트 게이트웨이, 리버스 프락시 역할 : 보안 HTTPS 트래픽 복호화, 웹 서버로 보낼 일반 HTTP 요청을 만든다.

⇒ 원 서버보다 효율적이지만 게이트웨이와 원 서버 간 암호화 없는 트래픽으로 안전한지 확인이 필요

## 8.3 리소스 게이트웨이

게이트웨이를 통한 리소스 요청 들어오면 서버는 필요한 데이터(Query 등)를 전달 받을 헬퍼 애플리케이션 생성하여 요청 처리. 이후 응답을 클라이언트에게 처리

### 8.3.1 공용 게이트웨이 인터페이스 (CGI)

최초 서버 확장으로 동적 HTML, DB 질의 등에 쓰이는 인터페이스로 요청에 따라 처리 단계를 감추어 확장에 있어서 서버를 보호한다.

⇒ 요청마다 새로운 프로세스에 관한 부하가 커서 Fast CGI (데몬으로 동작)로 성능 저하 문제를 해결했다.

### 8.3.2 서버 확장 API

서버 자체 동작을 바꾸거나 서버 처리능력을 최고치로 끌어올리기 위해서 웹 개발자가 자신의 모듈을 직접 HTTP에 연결할 수 있는 ‘서버 확장 API’를 제공.

## 8.4 애플리케이션 인터페이스와 웹 서비스

데이터를 교환하려는 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일이 이슈. (헤더만으로는 힘든 복잡한 정보)

웹 서비스는 SOAP(HTTP 메시지에 XML 데이터를 담는 방식에 관한 표준)을 통해 XML(데이터 생성하고 해석하는 방식 제공)을 사용하여 정보를 교환한다.

## 8.5 터널

HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공.

HTTP 커넥션으로 HTTP 아닌 트래픽 전송이 가능, 다른 프로토콜을 HTT에 얹을 수 있음.

### 8.5.1 CONNECT로 HTTP 터널 커넥션 맺기

- Connect 요청 : 클라이언트가 게이트웨이에 터널을 연결하기 위함 (TCP 커넥션을 위해)
- Connect 응답 : HTTP 200 Connection Established 응답을 전송, Content-Type 포함할 필요 X (바이트를 그대로 전달)

### 8.5.2 데이터 터널링, 시간, 커넥션 관리

터널 통과 전달되는 데이터는 게이트웨이에서 볼 수 없어서 패킷의 순서나 흐름에 대한 가정을 할 수 없다.

클라이언트는 성능을 높이기 위해 CONNECT 요청을 보내고 응답 받기 전에 터널데이터 전송 가능.

⇒ 데이터 빨리 보내는 방법이지만 요청에 이어서 게이트웨이가 적절하게 처리하는 것을 전제로 함.

- 네트워크 I/O 요청이 헤더 데이터만을 반환해줄 거라고 가정할 수 없어서, 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터 서버에 전송해야한다. 요청 후 터널 통해 전송한 클라이언트는 응답의 요청 데이터를 다시 보낼 준비가 되어있어야한다.

### 8.5.3 SSL 터널링

방화벽을 통해 암호화된 SSL 트래픽 전달 위해 개발

⇒ 정보가 암호화 되어 낡은 프락시에서는 처리가 힘듦

⇒ SSL 트래픽이 기존 프락시 방화벽 통과 위해 HTTP 커넥션으로 전송하여 80 포트의 HTTP 만 혀용하는 방화벽 통과 시킬 수 있음.

### 8.5.4 SSL 터널링 vs HTTP/HTTPS 게이트웨이

HTTPS와 SSL 세션을 시작하는 게이트웨이, 클라이언트측의 HTTPS 트랜잭션 수행. 응답은 프락시 복호화 이후, HTTP 를 통해 클라이언트로 전송,

⇒ 보안 적용안된 HTTP 커넥션 맺어진다. 프락시가 인증 담당이어서 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없다. 게이트웨이는 SSL 완벽 지원해야한다.

SSL 터널링으로 프락시 SSL 구현 필요가 없어짐.

⇒ SSL 세션은 클라이언트가 생서한 요청과 목적지 웹 서버 간에 생성, 프락시 서버는 트랜잭션 보안에 관여하지 않고 암호화된 데이터 그대로 터널링

### 8.5.5 터널 인증

프락시 인증 기능은 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용가능

### 8.5.6 터널 보안 고려사항들

특정 포트 터널링할 수 있게 허용

## 8.6 릴레이

HTTP 명세를 완전히 준수하지는 않는 간단한 HTTP 프락시.

커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달. ( 복잡한 HTTP 로직을 수행하지 않고 트래픽을 전달하는 것이 유용할 때가 있다. 단순 필터링, 콘텐츠 변환에 이용)

⇒ Connection 헤더를 처리하지못해 keep-alive 커넥션이 hang에 걸리는 것.
