# 7장 캐시

웹 캐시는 자주 쓰이는 문서의 사본을 저장하여 웹 요청의 리소스를 원 서버가 아닌 자신으로부터 제공해준다.

## 7.1 불필요한 데이터 전송

캐시를 이용하여 복수의 클라이언트의 요청에서 오는 중복되는 리소스에 대한 서버의 부하를 줄인다.

⇒ 첫번 째 서버 응답을 캐시에 저장하여 다른 요청들에 대한 응답으로 사용

⇒ 원 서버의 트래픽 낭비 감소

## 7.2 대역폭 병목

원격 서버의 좁은 대역폭에서 떨어지는 전송 속도를 보완한다.

⇒ 원격 서버 쪽에 문서를 캐시를 해두어 빠르게 다운 받을 수 있다.

## 7.3 갑작스럽 요청 쇄도(Flash Crowds)

갑작스런 트래픽 증가로 인한 네트워크와 웹 서버의 심각한 장애 야기.

## 7.4 거리로 인한 지연

거리에 따른 라우터들의 전송 과정에서 트래픽이 지연될 수 있다.

## 7.5 적중과 부적중

- 적중 (cache hit) : 캐시에 요청 도착 시, 대응하는 사본으로 요청 처리
- 부적중 (cache miss) : 사본이 없으면 원 서버로 전달

### 7.5.1 재검사(Revalidation)

원 서버의 콘텐츠 변경에 대비해서 캐시의 사본이 최신인지 서버를 통해 점검해야한다.

HTTP는 서버로부터 전체 객체를 가져오지 않고도 콘텐츠를 검사할 수 있는 요청을 정의했다.

- 재검사 필요시 원 서버에 재검사 요청을 보낸다.
- 재검사 적중, 느린 적중 : 콘텐츠가 변경되지 않았다면, 서버는 304 Not Modified 응답을 보내고 캐시는 검증된 사본을 클라이언트에게 전달한다.
  - 성공한 재검사 적중은 서버로부터 객체 데이터를 받아올 필요가 없어서 부적중보다는 빠르다.

**If-Modified-Since 헤더**

HTTP가 캐시된 객체를 재확인 하기위해 서버의 GET 요청에 추가하여 캐시된 시간 이후에 **변경된 경우**에만 사본을 보내달라는 의미를 가진다.

- 재검사 적중
  - 서버 객체가 변경되지 않았을 경우, 서버는 304 Not Modified 응답 보낸다
- 재검사 부적중
  - 변경된 경우, 서버는 콘텐츠 전체와 200 OK 응답 보낸다
- 객체 삭제
  - 삭제된 경우, 서버는 404 Not Found 응답을 돌려보내고, 캐시는 사본을 삭제한다.

### 7.5.2 적중률

캐시가 요청을 처리하는 비율 (문서 적중률)

- 캐시의 크기, 캐시 사용자들의 유형, 캐시 데이터의 변경이나 개인화 등 설정에 달려 있음.

### 7.5.3 바이트 적중률

캐시를 통해 제공된 모든 바이트의 비율 = 트래픽이 네트워크가 아닌 캐시에서부터 온 비율

- 문서 적중률의 개선으로 트랜잭션이 줄어들면서 트랜젝션 전체 대기시간이 줄어든다.
- 바이트 적중률 개선으로 대역폭 절약을 최적화한다.

### 7.5.4 적중과 부적중의 구별

HTTP는 응답의 적중 여부를 제공하지 않고 200 OK로 나온다.

Via 헤더를 추가로 붙이는 경우도 있음.

- Date 헤더를 이용해서 응답의 생성일이 현재 시각보다 더 오래되었다면 캐시되었다고 알 수 있음
- Age 헤더로 수신자에게 응답이 얼마나 오래되었는지 알려줌.

## 7.6 캐시 토폴로지

### 7.6.1 개인 전용 캐시 (Private cache)

- 웹브라우저 캐시

### 7.6.2 공용 프락시 캐시 (Public cache)

- 로컬 캐시에서 문서를 제공하거나 사용자의 입장에서 서버에 접근 : 공유된 캐시로 트래픽을 줄일 수 있다.

### 7.6.3 프락시 캐시 계층들

작은 캐시에서 캐시 부적중이 발생한 경우 부모 캐시가 남은 트래픽을 처리하도록 하는 경우 : 합리적

- 클라리언트 주위에 작고 저렴한 캐시 이용, 계층 상단에 큰 캐시 이용해 많은 사용자들에 의해 공유되는 문서 유지
  - 캐시 계층이 깊어진다면 프락시 연쇄로 성능 저하가 발생한다 (현재는 고성능)

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

캐시망의 프락시 캐시는 캐시 커뮤니케이션 결정을 동적으로 내림.

- 콘텐츠 라우팅 설계
  - URL 근거 부모 캐시와 원 서버 중 하나를 동적으로 선택
  - URL 근거 특정 부모 캐시를 동적으로 선택
  - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아봄
  - 다른 캐시들이 콘텐츠에 부분적으로 접글할 수 있도록 허용하되, 캐시를 통한 인터넷 트래픽을 다른 네트워크로 넘기는 것은 허용하지 않는다
- 서로 다른 조직들이 상호 이득을 위해 캐시를 연결하는 선택적 피어링을 지원.
  - HTTP는 이를 지원하지 않아서 HTTP를 확장했다. (ICP, HTCP)

## 7.7 캐시 처리 단계

### 7.7.1 단계 1 : 요청 받기

캐시는 네트워크 커넥션에서의 활동을 감지하고 들어오는 데이터 읽어들인다.

고성능 캐시는 데이터 동시에 읽어들이고 메시지 전체가 도착하기 전 트랜잭션 처리를 시작한다.

### 7.7.2 단계 2 : 파싱

요청 메시지를 여러 부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료 구조에 담아 처리를 쉽게 만든다.

### 7.7.3 단계 3 : 검색

URL을 알아내고 로컬 사본을 검사하여 객체를 캐시해온다.

- 캐시된 객체는 서버 응답 본문과 원서버 응답 헤더를 포함
  - 객체가 캐시에 머무는 기록이나 사용된 기록 등의 메타데이터를 포함

### 7.7.4 단계 4 : 신선도 검사

캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 한다 : 신선한 상태

신선하지 않은 경우 ⇒ 재검사필요

### 7.7.5 단계 5 : 응답 생성

캐시된 서버 응답 헤더를 토대로 생성된 기저 헤더들은 캐시에 의해 수정되고 늘어남.

- 캐시는 클라이언트에 맞게 헤더 조정이 필요 (ex) HTTP/1.1 필요에서 HTTP/1.0 반환의 경우 번역 필요
- 캐시 신선도 정도 삽입 (Cache-Control, Age, Expires 헤더), Via 헤더 포함 : Date 헤더는 조정 X

### 7.7.6 단계 6 : 전송

응답 헤더 준비 후 캐시는 클라이언트와의 커넥션을 유지하며 응답을 돌려준다.

- 고성능 캐시는 로컬 저장장치와 네트워크 I/O 버퍼 사이에서 문서 콘텐츠 복사를 피함으로 데이터 전송을 위해 노력

### 7.7.7 단계 7 : 로깅

캐시는 로그 파일과 사용에 대한 통계를 유지.

- 로그 포맷 형식에 맞춰서 트랜젝션 완료 후, 통계 캐시 적중과 부적중 횟수에 대한 통계 갱신 : 로그파일에 종류, URL 등 항목 추가

## 7.8 사본을 신선하게 유지하기

문서 만료와 서버 재검사를 통해 캐시된 사본이 서버와 충분히 일치하도록 유지

### 7.8.1 문서 만료

HTTP는 Cache-Control과 Expires 헤더 이용 문서 유효기간 붙일 수 있도록 한다.

### 7.8.2 유효기간과 나이

> **Expires : Fri, 05 Jul 2022, 05:00:00 GMT
> Cache-Control : max-age=48200**

- Expires : 절대 유효기간 명시 (옛날 방식)
- Cache-Control : max-age는 최대 나이를 정의해서 신선하지 않을 때까지 경과한 시간의 합법적 최댓값

### 7.8.3 서버 재검사

검사를 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어보는 것.

- 매 요청마다 검증할 필요가 없어서 문서 만료시 한 번만 서버와 재검사
  - 신선한 컨텐츠 제공하고, 서버 트래픽 절약하여 사용자 응답 시간 개선.
- HTTP 프로토콜의 캐시가 다음 중 하나를 반환할 것을 요구
  - ‘충분히 신선한' 캐시된 사본
  - 에러 메시지 (원 서버 다운되었을 때 방지)
  - 부정확한 캐시에 대해 경고 메시지 부착된 사본

### 7.8.4 조건부 메서드와의 재검사

- HTTP 조건부 메서드는 재검사를 효율적으로 해준다.
  - **조건부 GET**
    - 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라하고 하는 것. (신선도 검사 + 객체를 받아오는 것)
    - 특별한 GET 요청 메시지에 특별한 조건부 헤더를 추가 (조건이 참인 경우에만 객체 반환)
      - If-Modified-Since : 문서가 주어진 날짜 이후 수정되었을 때 요청 메서드 처리
        - 콘텐츠 변경된 경우에 Last-Modified 서버 응답 헤더와 함께 사용된다.
      - If-None-Match : 문서에 대한 일련번호와 같이 동작하는 태그 제공
        - 헤더는 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청 처리

### 7.8.5 If-Modified-Since : 날짜 재검사

IMS 요청 : 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문 보내달라함

- 문서가 주어진 날짜 이후 변경 되면 IMS 조건은 참 ⇒ GET 요청은 평범하게 성공
  - 새로운 만료 날짜 + 다른 정보들이 담긴 헤더들과 함께 캐시에게 반환
- 거짓인 경우 ⇒ 304 Not Modified 반환 (효율을 위해서 본문을 보내지 않는다)
  - 응답은 헤더를 포함하지만 갱신이 필요한 것만 보내줌
    - Content-Type 헤더는 대게 보내줄 필요가 없고, 새 만료 날짜를 보내주게 됨.

IMS 헤더는 Last-Modified 헤더와 함께 동작

- 원서버는 제공하는 문서에 최근 변경 일시를 붙임.
- 캐시가 재검사시에 사본이 **If-Modified-Since : <캐시된 마지막 수정일>** 헤더를 포함

몇몇 웹 서버는 IMS 날짜와 최근 변경일 간의 문자열 비교를 수행

- 날짜 이후 변경이 아닌 날짜에 마지막 변경이 일어난 것이 아니라는 것에 의미를 둔다
  - 일련번호를 최근 변경 일시로 사용한다면, IMS를 시간으로 활용할 수는 없지만 캐시 만료 관련 동작에는 문제가 없다

### 7.8.6 If-None-Match : 엔터티 태그 재검사

- 최근 변경 일시 재검사가 적절히 행해지기 어려운 상황
  - 내용의 변화가 없지만 변경시각이 바뀌는 경우
  - 데이터 변화의 중요도가 낮은 경우
  - 페이지에 대한 최근일자 정확히 판별 어려운 경우
  - 1초보다 작은 간경의 경우 정밀도가 낮다
  예로 엔터티 태그의 변경의 경우를 확인하기 위해서 If-None-Match에 엔티티 버전을 기입하여 그 사실을 확인할 수 있다.

### 7.8.7 약한 검사기와 강한 검사기

서버의 것이 최신인지 확인하기 위해 엔터티 태그를 사용

- 콘텐츠 변경의 중요도가 낮은 경우 - weak validator
- 콘텐츠가 바뀔 때마다 변경 - strong validator
  ⇒ ‘W/’ 접두사로 약한 검사기 구분 (ETag : W/”2.6v”)

원 서버는 서로 다른 의미의 두 엔터티에 대해서 태그 값을 재활용해서는 안된다.

유효기간에 상관없이 캐시 항목은 임의의 기간동안 지속 될 수 있으므로, 캐시가 과거 특정 시점에서 얻은 검사기를 사용해 캐시 항목을 다시 검사하려 시도하지 않을 것이라는 예상은 틀릴 수 있다.

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- HTTP/1.1 클라이언트는 서버가 엔터티 태그 반환 시 엔터티 태그 검사기를 사용해야한다.
- 서버가 Last-Modified 값을 반환하면 클라이언트는 IMS 검사를 사용할 수 없다.
- 엔터티 태그와 IMS 모두 사용 가능하다면 클라이언트는 두 가지의 재검사 정책을 모두 사용해야 한다.
- HTTP/1.1 원 서버는 엔터티 태그 검사기를 보내야하고, Last-Modified 값을 같이 보내는 것도 선호.
- HTTP/1.1 캐시나 서버가 IMS 엔터티 태그 조건부 헤더를 모두 받았다면, 조건부 헤더 필드 조건에 부합되지 않는 한 304 Modified 응답을 반환해서는 안된다.

## 7.9 캐시 제어

캐시를 제어하는 헤더

HTTP/1.1은 신선도 관리를 위해 객체 캐시를 제한하거나 캐시된 객체를 제공하는 방법 제공.

### 7.9.1 no-cache와 no-store 응답 헤더

캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막는다.

- Cache-Control : no-store ⇒ 캐시가 응답의 사본을 만드는 것을 금지
  - 프락시 서버가 그러는 것처럼 클라이언트에게 no-store 응답을 전달하면 객체를 삭제할 것
- Cache-Control : no-cache ⇒ 로컬 캐시 저장소에 저장될 수 있지만 재검사 없이 클라이언트에게 제공될 수 없을 뿐

### 7.9.2 Max-Age 응답 헤더

- Cache-Control : max-age ⇒ 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간, 초
  - 서버는 maximum aging을 0으로 설정해서 캐시가 매 접근마다 문서를 캐시하거나 리프레시하지 않도록 요청할 수 있다.

### 7.9.3 Expires 응답 헤더

- Expires 헤더는 초 단위의 시간 대신 실제 만료 날짜를 명시 : 정확하지 않은 시간으로 절대시각 대신 경과된 시간으로 표현하는 것이 낫다고 판단.

### 7.9.4 Must-Revalidate 응답 헤더

- 만료 정보를 엄격하게 따르길 원할 때 이용
- Cache-Control : must-revalidate → 캐시가 이 객체의 만료된 사본을 원 서버와의 최초의 재검사 없이 제공해서는 안된다. 이 때 검사시 서버 사용할 수 없는 상태면 캐시는 504 Gateway Timeout error를 반환해야.

### 7.9.5 휴리스틱 만료

응답이 max-age, expires 헤더 중 어느것도 없으면 heuristic 방법으로 최대 나이를 계산

- 계산 결과 얻은 최대 나이 값이 24시간보다 크다면, Heuristic Expiration 경고 헤더가 응답 헤더에 추가되어야 한다. 이 경고 정보를 사용자가 볼 수 있게 해주는 브라우저는 거의 없다.
- **LM 인자 알고리즘 : 최근 변경 일시를 포함하고 있다면 사용 가능. 최근 변경 일시를 문서가 얼마나 자주 바뀌는지에 대한 추정에 사용**
  - 캐시된 문서가 마지막으로 변경된 것의 시간이 오래 전이라면, 안정적인 문서로 보관 기간이 길어도 안전하다
  - 최근에 변경되었다면, 자주 변경될 것이고 서버와 재검사하기 전까지 짧은 기간 동안만 캐시해야한다.
  - 캐시가 서버와 소통 시에 서버가 문서의 최근 변경 일시를 알려주면 시간차를 계산해 일부를 캐시의 신선도 지속기간으로 사용.
  - 사이트 캐시 시간(신선도 유지기간) 설정, 신선도 단서가 없는 문서는 기본 신선도 유지기간을 설정

### 7.9.6 클라이언트 신선도 제약

웹 브라우저는 브라우저나 프락시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시 버튼 가짐.

- Cache-control 요청 헤더가 추가된 GET 요청을 발생시켜 강제로 재검사하거나 서버로부터 콘텐츠를 무조건 가져옴
- 클라이언트는 Cache-Control 요청 헤더를 사용해 만료 제약을 조절할 수 있음
  - 문서 최신 유지를 위해서 엄격하게, 성능, 신뢰성, 비용 개선을 위해 느슨하게 할 수도.

### 7.9.7 주의점

유효기간 설정에 오류가 있으면 만료되기 전까지 문서 변경 사항이 캐시에 반영되지 않을 것
