# 12장 기본 인증

허가된 사용자만이 데이터에 접근하고 서비스를 이용하기 위해서는 서버는 사용자가 누구인지 식별할 수 있어야 한다.

‘인증'을 통해서 사용자에게 작업이나 리소스에 접근할 수 있는지 서버는 결정권을 줄 수 있다.

## 12.1 인증

### 12.1.1 HTTP의 인증요구/응답 프레임워크

- HTTP 요청 메시지를 받으면, 서버는 요청 처리 대신에 현재 사용자가 누구인지 알 수 있게 비밀번호 같이 개인 정보를 요구하는 ‘인증 요구'로 응답할 수 있다.
- 인증 정보를 입력 (인가) 과정을 거치고 요청을 보내면 서버는 그를 확인하고 인증 요구를 보내거나 에러를 낼 수 있다.

### 12.1.2 인증 프로토콜과 헤더

HTTP는 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제어 헤더를 통해 제공한다.

- 기본인증
  1. 요청 GET
  2. 인증 요구 401 Unauthorized (서버 → 사용자)
     - WWW-Authenticate 헤더를 기술해서 어디서 어떻게 인증할지 설명
  3. 인증 GET
     - Authorization 헤더에 인증 정보를 담아 보낸다
  4. 성공 200 OK
     - Authentication-info에 인증 세션에 관한 추가 정보를 기술해서 응답하기도 한다
- 다이제스트 인증
- OAuth

### 12.1.3 보안 영역

어떻게 HTTP가 각 리소스마다 다른 접근 조건을 다루는가

- 인증 요구 단계에서 WWW-Authentication헤더의 realm으로 그룹을 나눈다.

## 12.2 기본 인증

웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있다. 서버는 401 상태코드와 함께 클라이언트가 접근하려고 했던 보안 영역을 기술해서 응답하여 인증요구를 시작한다. 인증 정보 포함 요청을 받은 브라우저는 사용자에게 사용자 이름과 비밀번호를 Authorization 요청 헤더 안에 암호화해서 서버로 다시 보낸다. (base-64로 인코딩)

- Authentication-info 헤더를 사용하지 않는다.

### 12.2.2 Base-64 사용자 이름/ 비밀번호 인코딩

기본 인증은 사용자 이름과 비밀번호를 콜론으로 이어서 합치고, base-64 인코딩 메서드를 사용해 인코딩 한다.

- base-64인코딩
  - 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명
  - 8비트 바이트 시퀀스를 6비트 덩어리 시퀀스로 변환 (문자 숫자로 이루어진 64개의 문자중에서 선택)
  - 국제 문자나 HTTP 헤더에 사용할 수 없는 문자를 포함할 때 유용하고, 사용자 이름과 비밀번호 문자를 섞을 수 있어 개인정보 보호에 도움이 된다.
  - 예시
    - ‘brain-totty’ / ‘Ow!’ ⇒ ‘brain-totty:Ow!’ ⇒ 인코딩

### 12.2.3 프락시 인증

프락시 서버를 이용하여 통합적인 접근제어를 하기 위해 사용

## 12.3 기본 인증의 보안 결함

- base-64의 디코딩이 어렵지 않아 정보가 유출될 수 있다. ⇒ SSL 채널 이용, 다이제스트 인증 이용
- 인코딩 된 정보를 그대로 캡쳐하여 이용할 수 있지만 재전송 공격 예방이 안되어 있다.
- 메세지 인증 헤더 이외의 부분을 수정하는 프락시나 중개자의 개입으로 정상적인 동작이 안 될 수 있다.

⇒ 기본 인증은 개인 정보를 숨기려고 암호화된 데이터 전송과 함께 연계해서 사용하는 것이 좋다.
